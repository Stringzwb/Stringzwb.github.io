# 一、MQTT（Message Queuing Telemetry Transport）
MQTT 是基于二进制消息的发布/订阅编程模式的消息协议（是一种基于发布/订阅模式的轻量级通讯协议）。

## 发布/订阅模式的好处：
1.只需要一个消息代理（发布者和订阅者不用了解彼此）

2.发布者和订阅者不直接建立联系，发布者无需等待订阅者确认而进入锁定状态

3.可以自由选择时间来消费信息，发布者和订阅者不用同时在线

## **Broker 中心节点**：
客户端（传感器/设备）发布消息，订阅者由 Broker 派发数据。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755221032654-6439de06-ad6c-43c1-bc98-23f3f815e8fa.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755221178338-0157b0aa-e9c0-4fe9-982c-42d192f68731.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755221290155-3ce3078b-0b7f-4130-91f2-d4731fd1c675.png)

## 应用消息：
MQTT协议通过网络传输应用数据，应用消息通过MQTT传输时，他们有关联的服务质量，QoS和主题topic。

### QoS：
服务质量QoS是消息可靠性的保障，MQTT为不同场景提供消息可靠性，提供了三种不同级别的服务质量。

三种 QoS 级别：

0：最多分发一次，消息发送者会想尽办法发送信息，但是遇到意外并不会送达（不保证送达）

1：至少分发一次（可能重复）

2：仅分发一次，这是最高等级的服务质量，消息丢失和重复都是不可接受的（保证一次且不重复）

### 主题topic：
MQTT是通过主题对消息进行分类的本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系；主题还可以通过通配符进行过滤，其中加号可以过滤一个层级，而星号只能出现在主题最后，表示过滤任何级别的层级。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755223997675-000e8aa8-8618-4bf8-9e82-3b48767d41e4.png)![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755224074459-56daae03-e671-426d-a031-fc1a6ca596a0.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755224176487-d0dd5418-4002-4dd1-982f-b927dbe7b231.png)

## MQTT协议的优势：
1. <font style="color:#DF2A3F;">功能精简</font>，不添加可有可无的功能。

2. 发布/订阅（<font style="color:#DF2A3F;">Pub/Sub</font>)模式。

3. 允许用户动态创建主题，<font style="color:#DF2A3F;">"零"</font>运维成本。

4. 把传输量降到<font style="color:#DF2A3F;">最低</font>以提高传输效率。

5. 把<font style="color:#DF2A3F;">低带宽，高延迟，不稳定的网络</font>等因素考虑在内。

6. 支持<font style="color:#DF2A3F;">连续</font>的会话控制。

7. <font style="color:#DF2A3F;">理解</font>客户端计算能力可能很低。

8. 提供<font style="color:#DF2A3F;">服务质量</font>管理。

9. 假设数据不可知，<font style="color:#DF2A3F;">不强求</font>传输数据的类型与格式，保持灵活性。

## 缺点：
1.需要维护 Broker（如 EMQX、Mosquitto）

2.调试比 HTTP 麻烦些

3.数据不结构化（通常需自定义 payload 格式）

# 二、HTTP（Hypertext Transfer Protocol）
HTTP，超文本传输协议（是最常见的应用层协议），是互联网通信的基础协议，采用 **请求-响应（Request-Response）** 模式，广泛用于 Web 开发、Rest API 等领域。

## HTTP的工作模式：
HTTP是基于客户端/服务器模式即C/S模式

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755242272614-4f4f52da-5080-491c-a1ed-37ce3a563eba.png)

## HTTP的工作原理：
![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755242361103-1feb135f-f51a-4a43-935b-786b94a5bf04.png)

### HTTP请求：
常见的请求方法：GET、POST、PUT、DELETE、PATCH。（每个请求独立）

HTTP请求遵循HTTP协议的相关规范，包括请求行、请求头、空行、请求体。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755242504781-8aa1ae50-00b8-4da8-9fda-b1cace75ceb5.png)

get和post请求的差异：

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755243085087-23ffb5e2-2ff3-44f5-8aca-5ec916f814c1.png)

### HTTP响应：
包括：状态行、响应头、空行、响应体

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755243506995-ac0d358b-b1c1-4828-ab6e-af3ea983e7d8.png)

200 OK：表示请求成功

404 Not Found：表示请求URL在网站中不存在

500 Internal Server Error：表示服务器内部出现了错误，无法正常处理请求

302 Found（重定向）：表示你请求的资源已经被临时移动到另外一个位置

401 Unauthorized（未授权）：表示没有权限访问请求的资源

503 Service Unavailable（服务不可用）：表示服务器当前无法处理你的请求，可能是太多请求了，或者其它原因导致服务不可用

## 优点：
1.全平台广泛支持

2.易于理解和实现

3.丰富的开发工具支持（如 Postman、curl）

## 缺点：
1.开销大（HTTP header 冗长）

2.实时性差（轮询或长连接才能实时）

3.对于低功耗设备不友好

# 三、Modbus
Modbus 是工业通信协议，广泛用于 **PLC、DCS、传感器、仪表** 之间的数据交换，尤其适用于工业自动化场景。

## Modbus通讯协议三种格式：
Modbus RTU

Modbus TCP

Modbus <font style="color:rgba(0, 0, 0, 0.9);">ASCII</font>

MODBUS通讯协议：是应用于工业自动化领域现在最为广泛的一种通讯协议。

<font style="color:rgba(0, 0, 0, 0.9);">它们其实就是硬件接口以及传输数据方式的不同。</font>

<font style="color:rgba(0, 0, 0, 0.9);">eg：</font>

### <font style="color:rgba(0, 0, 0, 0.9);">MODBUS TCP：</font>
<font style="color:rgba(0, 0, 0, 0.9);"> </font>![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755225404222-495d860e-2437-4e9b-97a7-c1a8e8a597ab.png)

<font style="color:rgba(0, 0, 0, 0.9);">它更多的是做一些网络的通信</font>

<font style="color:rgba(0, 0, 0, 0.9);">TCP：</font>

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755241115063-4bbbd736-5828-43f2-a27c-629eec828472.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755241388121-60525aee-f094-4eb7-9c34-9f6773cd97e5.png)

### <font style="color:rgba(0, 0, 0, 0.9);">MODBUS RTU（remote terminal unit远程终端协议）：</font>
<font style="color:rgba(0, 0, 0, 0.9);">是典型的主从模式，在通讯的过程中只允许主站发出请求，从站根据主站请求的内容返回相应的响应，不允许从站向主站发送发送请求。（工业中用得最多）</font>

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755240167246-04da0a17-9949-4a93-8b66-916a57178ee7.png)

<font style="color:rgba(0, 0, 0, 0.9);">从站地址的范围是1-247，所以一个主站最多只能拥有247个从站</font>

<font style="color:rgba(0, 0, 0, 0.9);">RTU：采用CRC校验算法</font>

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755240453481-1585fba4-6789-4ee5-b1c6-641abb3128d2.png)

## 报文结构（示例）
```plain
| 地址 | 功能码 | 数据 | CRC |
```

### 功能码示例（如上面图片）
01：读线圈状态

03：读保持寄存器

05：写单个线圈

06：写单个寄存器

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755225632539-cc7fa9fe-463a-4d00-91fa-40281738944d.png)

## 优点
简单易实现

通信高效（固定帧格式）

适合实时控制设备（毫秒响应）

## 缺点
数据结构单一（寄存器位）

安全性低（明文传输）

不适合广域网或互联网通信

## 工业中应用的实例：
工业中常见的一种最小的控制方式：左侧是一个工业触摸屏，右侧是一个控制器，控制器下设又连接了8个灯，控制器和屏幕是通过一根485总线连接的，使用的协议是MODBUS协议。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755225953913-76257a43-be12-4ba2-802d-b8b89dbdd25f.png)![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755226648670-f6b503ce-ef5d-4943-8f47-1cb6aa28661a.png)

控制器要实现对8个灯的控制，其内部最根本的地方是一片寄存器。

寄存器是一个特殊的存储器，它把空间里面的内容和相应的动作或相应的状态关联到一起。

所以可以通过寄存器查看当前设备状态，也可以通过设置寄存器的内容来实现对设备的控制。

而为了控制这8个灯，在控制器里面有8片空间，每个空间就是一个位，为了标注是位空间这里用M来表示，然后这8个空间和8个灯的状态绑在一块，要实现对灯的控制只需要对这片内存进行操作就可以了。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227263935-8e0096a7-5873-43ab-82e5-bc633273f84e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227384698-c0b4d8f5-21d6-431b-8155-e2934e126745.png)![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227409992-55d922d6-8d87-4100-96c8-628d57938c0a.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227441069-b9689b9c-6818-4f67-87a8-19a6da0a23c3.png)

在工程里面常见的形式是多个控制器的，它们是通过一个总线互联的，总线的特点是一根线可以接多个设备。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227646939-7a2ff39c-d09c-4101-bdd6-94475be8bbfd.png)![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227771739-eb789a6b-f5ad-48e8-a6e9-35c9ce46aefe.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755227925557-2c909848-be0c-45d5-8587-824e99069093.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755228006336-b66eb794-91ba-4b32-b929-871c00bb2c8a.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755228067147-1df9490b-7e6d-4f5e-a2a6-c6aaf8a34fc8.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755228190771-6855f262-1518-4756-ba11-b892fb8b17e7.png)

一个请求一个应答是MODBUS的一个周期，才能保证可靠传输，除了这种可靠传输机制，为了保证发出数据之后信号丢失，往往在主机设置一个最长等待时间，如果超过这个时间没有收到应答信号，我们就认为这次发送数据失败，就采取重新发送或者跳到下一条指令去执行。



线圈：是布尔存的是0/1

寄存器：一个寄存器是16个位

线圈或寄存器表示最小单位

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755238815843-70ca8144-8b9f-4d07-98b5-6ad31b7a5547.png)

# 四、TCP（transportcontrolprotocol)
传输控制协议（tcp.transportcontrolprotocol)是一个较为复杂的协议，其在不可靠的ip层之上实现了可靠传输。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755498618626-d0717b05-83fb-4563-a57c-70426f546227.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755498766025-7b43dce3-ae9a-454f-a0d1-83ed662c92e7.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755498921758-d2dfcb27-3d86-41e2-a25b-3713ba89df9e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755499032089-2bfe9a5a-0718-4260-a7d5-d5774970354d.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755499131067-244817f0-a276-44b0-bc7b-7697d52982cc.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755499230251-96e10595-cb52-44c6-ad0a-2660a12dd2a4.png)



传输层实际提供的是一种逻辑通信，简单说就是应用数据以不同的方式抵达目的地，TCP和UDP就是两种不同的方式

如果使用TCP不会马上发送数据，而是会先进行3次握手，握手后才会进行数据的发送，也就是面向连接。

握手就是为了建立一对一的服务，这样数据就可以在可靠的逻辑通信下进行传输。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755499829062-bd9aaebc-f6e3-4ea0-818f-c0bb917b6565.png)

如果使用UDP，不会进行握手，直接就可以发送数据了，也就是无连接。

这样不仅可以一对一，还可以一对多进行通信

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755500012615-3e7e57c9-40d0-4581-9776-ed36c6e3fddb.png)

TCP和UDP都提供端口，没有端口，你的应用要同时进行通讯就会出现问题。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755500383145-1e7126fe-f458-40cc-9475-e5dfd9dcb09a.png)

TCP和UDP的首部都存在端口，但是两者的首部是大大不同的。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755500468638-9aadd4ca-86d0-4634-9424-75e8ca671185.png)

TCP首部内容比UDP首部内容多的多，如果没有使用首部选项，TCP首部也需要用掉20字节，UDP首部是固定的8字节。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755500617201-ad17abc8-bb26-488b-bed6-dc1dffd5748d.png)

UDP的传输方式更加轻量化，速度相对较快。

TCP的开销则比较大，速度相对较慢。

TCP的开销用到了哪里？

首先就是‘序列号’和‘确认答应号’，应用层把数据交给TCP以后，如果数据比较大，TCP会拆成多个数据段，每个数据段都用‘序列号’进行标注，TCP把应用层的数据视为‘连续’的字节流，并且根据实际情况进行分片。

不过，TCP会把数据段交给网络层，不同网络状况都不太一样，因此这些数据段最终抵达的顺序不同也很正常，此时，就可以用‘序列号+’了，比如用‘序列号’+‘数据长度’就可以得到下一个数据段的序号，以此类推，即使接收方收到的是乱序的数据段，使用‘序列号’+‘数据长度’也可以把它们给进行重组。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755500827724-8ae1d465-a2ba-4af0-88ee-e7b0db8ef392.png)

另外‘序列号’本来就可以判断出哪些字段是重复的数据段，重复的就可以进行丢弃了。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755501569070-127129e6-004f-4af9-a59f-202e9db80ba8.png)

但是只有‘序列号’是不够的，我们是把数据发送出去了，并不知道数据抵达没有，因此‘确认答应号’就有它的意义了。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755501712578-562524de-7f26-41f5-a8b1-b3a321c75bb6.png)

回到刚才的‘序列号’+‘数据长度’，如果接收方收到这份数据段了，就可以用‘序列号’+‘数据长度’的和作为确认号进行返回。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755501878658-fc2334e1-61be-41c9-8e4c-39479f718515.png)

对于发送方就简单了，收到了确认号就说明抵达了，在指定时间内，没有收到确认号就说明某个数据段可能丢包了，丢包TCP就会进行重传，反正有确认号可以进行确认，这样就可以做到对方不缺失你的任何数据了。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755502133555-b676b867-25fa-4b0c-a59b-dc6d0bc905df.png)

因此TCP的可靠性极大程度上是依赖着首部里‘序列号’和‘确认答应号’的。但是UDP首部里是没有这两样东西的。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755502279122-7b4092bc-f76c-45cc-898d-7954c1328b11.png)

TCP就有了流量控制和拥塞控制

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755502401096-b68a8b72-07df-4b28-a233-6d6b73508dc2.png)

<font style="color:#DF2A3F;">流量控制</font>是针对发送双方的，简单来说就是让发送方放慢脚步，不要一下子发送太多数据，因为接收方此时还没有办法处理这么多数据。

窗口大小：这是接收方告诉发送方所能接受数据大小的重要信息，也就是告诉发送方不要发送超过‘窗口’大小的数据给我，既然‘窗口出现在TCP’首部里面，意味着接受方每次都会告诉发送方‘窗口’的大小，因为接收方处理数据可能一下子快，一下子慢，于是这个‘窗口’值就不断地发生变化，因此数据就不是分成固定的小块发送出去的，而是按照流量的方式，一会儿多，一会儿少地进行发送，核心就在于，接受方凭借着‘窗口’来调控发送方的速度以实现‘流量控制’的功能。

窗口值是固定65535字节大小的。超过这个数值就需要TCP‘窗口扩大’选项来加大窗口值，这样窗口值除了能伸缩，还能做到被加大拉长。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755509207624-355f0ec0-6c51-4cce-a60f-e59a1286d634.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755509516502-20c48333-df98-468f-b18c-dc0b2eef54fa.png)

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755521539468-d5654df5-e691-40a7-9964-0ff209620885.png)

<font style="color:#DF2A3F;">拥塞控制</font>则是针对发送双方中间的网络，TCP可以更有效的利用网络的带宽。



UDP在数据量小的时候就能做到简单高效，因此实时的语音和视频也很适合用UDP。

TCP比较适合文件传输和网页这方面。

TCP3次握手之后就建立了连接，这个时候客户端就可以发送HTTP请求了，然后服务器响应内容。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755503223327-6e3217db-7cee-44cf-9504-bd41e55befa7.png)

假设现在内容都交流完毕了，各自可能就会发起关闭连接的要求了，也就是4次挥手。注意客户端和服务端都能主动发起关闭请求。

![](https://cdn.nlark.com/yuque/0/2025/png/57852232/1755503753369-ec867e6b-d222-4a27-9de0-7598a8395531.png)

假设这里是客户端主动发起关闭请求，这个时候客户端会在报文中开启FIN和ACK两个控制位。FIN就是Finish结束的意思，这里也就是确认结束会话，因为在发送HTTP请求和响应的时候序列号和确认号被不断递增，因此这里就不用固定数字来表示序号和确认号了。

此时一般服务端会先发送一个ACK来进行确认，套路和前面一样，自己的序列号用对方的确认号，自己的确认号用对方的序号+1，虽然发送了TCP报文，但此时客户端并未正式关闭通道，因为服务端那边可能还有需要发送的数据。

等服务端发送完数据以后会再发送一个FIN+ACK来进行最后的确认，此时序号和确认号不需要改变，因为没有一来一回，只是多了一个控制位FIN来进行确认结束步骤而已。

最后客户端得到最终的结束确认以后会发送ACK来进行确认，此时自己的序号需要用对方的确认号，自己的确认号用对方的序号+1。

其实中间的ACK和FIN+ACK两步就足以证明为什么要4次挥手，因为可能还存在未发送完毕的数据。







# 
